function f1(){
    console.log("f1");
}

function f2(){
    console.log("f2");
}

function f3(){
    console.log("f3");
}

function main(){
    console.log("main");

    setTimeout(f1, 50);
    setTimeout(f2, 30);

    new Promise((resolve, reject) => {
        resolve("I am a Promise, right after f1 and f3! Really?");
    }).then(resolve=>console.log(resolve));

    new Promise((resolve, reject) => {
        resolve("I am a Promise, right after Promise!");
    }).then(resolve=>console.log(resolve));

    f2();
}

main();

// ========================== Пояснение кода:

// Сначала выполняется функция main(), и в консоль выводится "main".

// Затем вызываются два таймаута с помощью setTimeout. Эти функции (f1 и f2) добавляются в очередь событий для выполнения 
// после истечения указанного времени (50 миллисекунд для f1 и 30 миллисекунд для f2).

// Далее создаются два промиса с разрешением, которые сразу же выполняются и вызывают функции then для вывода сообщений в консоль.

// Затем вызывается функция f2() сразу, и в консоль выводится "f2".

// ========================== Как работает Event Loop:

// Начально выполняется главный код (функция main()).
// Затем Event Loop начинает мониторить очередь событий. В этой очереди есть два таймаута (setTimeout) и два успешно разрешенных промиса.
// Event Loop выбирает событие с наименьшим временем задержки (т.е., событие с setTimeout равным 30 миллисекундам). 
// Он выполняет функцию f2, и в консоль выводится "f2".

// Далее Event Loop выбирает событие с setTimeout равным 50 миллисекундам и выполняет функцию f1. В консоль выводится "f1".

// Затем Event Loop выбирает первый успешно разрешенный промис и выполняет его обработчик then,
// который выводит сообщение "I am a Promise, right after f1 and f3! Really?" в консоль.

// Затем Event Loop выбирает второй успешно разрешенный промис и выполняет его обработчик then, 
// который выводит сообщение "I am a Promise, right after Promise!" в консоль.

// Таким образом, порядок выполнения событий в Event Loop позволяет асинхронным операциям, 
// таким как таймауты и промисы, выполняться в правильном порядке, и управлять выполнением кода в неблокирующем режиме.